# リーダブルコードをメモしていく
## 第７章　制御フローを読みやすくする

- 条件式の書き方
  - 変化するものが左、右に比較対象の式<br>
    🙆‍♂️`if length > 10: # 左に定数`<br>
    🙅`if bytes_expected > bytes_received: # 基準となるものが右`
- if/else文のルール
  - 条件は否定系よりも肯定系
  - 単純な条件を先に書く
  - 関心を引く条件や目立つ条件を先に書く
- 三項間演算子について
  - `1 if a == 1 else 2`のように単純に1か2の2択であればわかりやすい
  - `(num << tmp) if a == 1 else (num << -tmp)` のように分岐後にさらに操作があると見にくい -> if/else文の方が良い

- do/while文は避ける
- 関数から早く出すのはok
- クリーンナップコードを使用する(with open~など)
- gotoは複雑になるので使わない
- **ネストを浅くする**
  - できることならif文のなかにif文などは避ける

## 第８章 巨大な式を分割する
- 説明変数を用いる<br>
  ```
  #before
  if line.split(":")[0].strip() == "root":

  #after -> 説明変数をおく
  username = line.split(":")[0].strip()
  if username == "root"
  ```
- 要約変数を用いる
  ```
  # before
  if request.user.id == document.owner_id:
    hogohoge
  if request.user.id != document.owner_id:
    hugahuga
  ```
  - 対して大きな式ではないが、コードが本当に言いたいことを考える
  - このコードが言いたいのは「ユーザは文章を所持しているか？」
  ```
  # after
  user_owns_document = (request.user.id == document.owner_id)
  if user_owns_document:
    hogehoge
  if !user_owns_document:
    hugahuga
  ```
- ドモルガンの法則で論理式を書き換える
- 「頭がいい」コードに気をつける(１行に落とし込めるのが偉いわけではない！)
  - `x = a || b || c `の演算子の効果を確認(TODO)
- より優雅な方法を見つける（反対を考えてみるなど）

## 9章 変数と読みやすさ
- 役に立たない一時変数
  ```
  # このnowはいるか？　複数は使われてないし、datetime.datetime.now()はぱっと見でも理解できるものでは？
  now = datetime.datetime.now()
  root_message.last_view_time = now
  ```
- タスクはできるだけ早く返す
  ```
  # before
  def remove_one(array, value_to_remove):
    index_to_remove = null
    for i in range(len(array)):
      if array[i] == value_to_remove:
        index_to_remove = i
        break

  if index_to_remove != null:
    # index_to_remove番目の値を削除
  ```
  - このコードでindex_to_removeは必要だったのか？
  ```
  # after -> 早めに返すことは悪くない。むしろいいこと
  def remove_one(array, value_to_remove):
    for i in range(len(array)):
      if array[i] == value_to_remove:
        # i番目の要素を削除
        return
  ```

- 宣言の位置と使用する位置ができるだけ飛ばないようにする
- **定数の位置を下げる**
  - 初めにたくさん定義あると、読んでいる人はこれから変数全てのことを考慮に入れないといけなくなる
- 一度だけ書き込む変数を使う
  - イミュータブルな変数で宣言すれば、読む人は安心して読み続けられる

## 第10章 ⭐ここから大事そう！！
- 無関係の下位問題を積極的に見つけて抽出すること
  1. 関数やコードブロックを見て「このコードの高レベルの目標は何か？」を自問する
  2. コードの各行について「高レベルの目標に直接的に効果があるのか？あるいは、無関係の下位問題を解決しているのか？」と自問する
  3. 無関係の下位問題を解決しているコードが相当量あればそれらを抽出して別の関数にする
- 純粋なユーティリティコード(ファイルを読み込むなど)
- プロジェクトから完全に切り離された関数を作る
- プロジェクトに特化した機能
  - 表現をプリコンパイルする、規則性のあるパターンを作る p137の例を見る

## 11章 １度に1つのことを (コードの例が多いので知りたいときは読み返す)
- **関数は一度に1つのことを行うべき**
  1. コードが行っているタスクを全て列挙する
  2. タスクをできるだけ異なる関数に分割する
 
## 12章 コードに想いを込める
- ロジックを明確に説明する
  - if文の中が空になったとしても、ロジックとしてわかりやすければそっちの方がいい
    ```
    # good
    if(~を満たす) -> 何もしない
    elif(~を満たす) -> 何もしない
    else -> 権限なしでreturn 

    # bad
    if(~を満たさない) -> 権限なし
    elif(~を満たさない、かつ~を満たさないかつ~~) -> 権限なし
    else
      if(~を満たさない) -> 権限なし
      else -> 何もしない
    ```
- ライブラリを知る
  - より簡単に実装できるものが提供されているかも？
- **解決策を言葉で表す**
  - ~するにはどうすればいいかを言語化する
    1. ~する
    2. ~する
    3. ~して終わり

## 13章 短いコードを書く
- 昨日の実装について悩まない。きっと必要ない
- 質問と要求の分割
  - 店舗検索システムの例
    - 要求：任意のユーザの緯度経度に対して、最も近い店舗を検索する
      - 日付変更線を跨いでいるときは？
      - 北極や南極に近いときの処理は？
    - 実際：テキサス州のユーザのために、テキサス州で最も近くにある店舗を検索
      -> 現段階ではそんな心配はいらない！削除！！
- コードを小さく保つ
- 身近なライブラリに親しむ
- ライブラリの再利用は、コードを小さく保つ上でかなり大事
- Unixツールボックスを使う
